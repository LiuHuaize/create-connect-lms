# 数据库性能优化分步实施指南

基于项目代码分析，本指南将优化方案分解为具体的可执行步骤。

## 📋 实施概览

**目标**: 解决数据库不稳定、课程加载缓慢、缓存无效等问题  
**预期效果**: 查询速度提升60-80%，缓存命中率85%+，重复请求减少90%

---

## 🚀 阶段一：立即执行 - 数据库索引优化 (30分钟)

### 步骤 1.1: 添加关键数据库索引

**执行方式**: 使用Supabase MCP工具执行SQL

```sql
-- 为course_enrollments表添加复合索引 (最关键)
CREATE INDEX IF NOT EXISTS idx_course_enrollments_user_course 
ON course_enrollments(user_id, course_id);

-- 为courses表添加状态和作者索引
CREATE INDEX IF NOT EXISTS idx_courses_status_author 
ON courses(status, author_id);

-- 为lessons表添加模块和顺序索引
CREATE INDEX IF NOT EXISTS idx_lessons_module_order 
ON lessons(module_id, order_index);

-- 为course_modules表添加课程和顺序索引
CREATE INDEX IF NOT EXISTS idx_course_modules_course_order 
ON course_modules(course_id, order_index);

-- 为lesson_completions表添加复合索引 (优化进度查询)
CREATE INDEX IF NOT EXISTS idx_lesson_completions_user_course
ON lesson_completions(user_id, course_id);
```

**验证方法**:
```sql
-- 检查索引是否创建成功
SELECT indexname, tablename, indexdef 
FROM pg_indexes 
WHERE tablename IN ('course_enrollments', 'courses', 'lessons', 'course_modules', 'lesson_completions')
AND indexname LIKE 'idx_%';
```

**预期结果**: 应该看到5个新索引被创建

### 步骤 1.2: 验证性能改善

**测试查询性能**:
```sql
-- 测试课程注册查询 (最频繁的查询)
EXPLAIN ANALYZE 
SELECT id, progress, status 
FROM course_enrollments 
WHERE user_id = '你的用户ID' AND course_id = '某个课程ID';

-- 测试课程模块查询
EXPLAIN ANALYZE 
SELECT * FROM course_modules 
WHERE course_id = '某个课程ID' 
ORDER BY order_index;
```

**成功标志**: 查询计划显示使用了索引扫描而不是全表扫描

---

## 🔧 阶段二：前端缓存统一优化 (2-3小时)

### 步骤 2.1: 移除IndexedDB缓存层

**文件**: `src/lib/indexedDBCache.ts`

**修改**:
```typescript
// 完全禁用IndexedDB缓存的自动清理
(function setupAutoCleaning() {
  console.log('IndexedDB缓存已禁用 - 使用React Query作为唯一缓存层');
  // 注释掉所有自动清理代码
})();

// 修改缓存服务API，让所有方法返回null或空操作
export const indexedDBCache = {
  async saveCourseDetails(courseId: string, data: any): Promise<void> {
    // 禁用：直接返回，不保存
    return;
  },
  
  async getCourseDetails(courseId: string, maxAge = DEFAULT_CACHE_EXPIRY): Promise<any | null> {
    // 禁用：直接返回null，强制使用React Query
    return null;
  },
  
  async saveEnrollment(courseId: string, userId: string, data: any): Promise<void> {
    // 禁用：直接返回，不保存
    return;
  },
  
  async getEnrollment(courseId: string, userId: string, maxAge = DEFAULT_CACHE_EXPIRY): Promise<any | null> {
    // 禁用：直接返回null，强制使用React Query
    return null;
  },
  
  // 其他方法保持不变，供管理页面使用
  clearCourseCache: (courseId: string) => db.clearCourseCache(courseId),
  clearAllCache: () => db.clearAllCache(),
  clearExpiredCache: (expireTime = DEFAULT_CACHE_EXPIRY) => db.clearExpiredCache(expireTime),
  getCacheStats: () => db.getCacheStats()
};
```

**验证**: 检查浏览器控制台，不应再看到"从IndexedDB缓存返回"的日志

### 步骤 2.2: 移除localStorage缓存

**文件**: `src/hooks/useCoursesData.ts`

**修改缓存助手函数**:
```typescript
// 禁用localStorage缓存函数
const getFromLocalCache = (key: string) => {
  // 禁用：直接返回null，强制使用React Query
  return null;
};

const saveToLocalCache = (key: string, data: any) => {
  // 禁用：直接返回，不保存
  return;
};
```

**验证**: 检查localStorage，不应再有新的课程缓存项

### 步骤 2.3: 统一React Query缓存配置

**文件**: `src/App.tsx`

**修改QueryClient配置**:
```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // 统一缓存策略
      staleTime: 5 * 60 * 1000,     // 5分钟标记为过期
      gcTime: 15 * 60 * 1000,       // 15分钟后清理
      refetchOnWindowFocus: false,  // 禁用窗口聚焦时重新获取
      refetchOnMount: false,        // 禁用组件挂载时重新获取
      retry: 1,                     // 失败时最多重试1次
      retryDelay: 1000,            // 重试延迟1秒
    },
  },
});
```

**文件**: `src/pages/course/hooks/useCourseData.ts`

**统一缓存配置**:
```typescript
const UNIFIED_CACHE_CONFIG = {
  // 课程详情 - 较长缓存时间
  courseDetails: {
    staleTime: 10 * 60 * 1000,    // 10分钟
    gcTime: 30 * 60 * 1000,       // 30分钟
    retry: 2,
    retryDelay: (attemptIndex: number) => Math.min(1000 * 2 ** attemptIndex, 30000),
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  },
  // 注册信息 - 中等缓存时间
  enrollment: {
    staleTime: 5 * 60 * 1000,     // 5分钟
    gcTime: 15 * 60 * 1000,       // 15分钟
    retry: 1,
    retryDelay: 1000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  },
  // 课程列表 - 短缓存时间
  courseList: {
    staleTime: 3 * 60 * 1000,     // 3分钟
    gcTime: 10 * 60 * 1000,       // 10分钟
    retry: 1,
    retryDelay: 1000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  }
};

// 替换原有的CACHE_CONFIG
const CACHE_CONFIG = UNIFIED_CACHE_CONFIG;
```

**验证**: 检查网络面板，相同请求在缓存时间内不应重复发送

### 步骤 2.4: 清理已有缓存冲突

**立即执行清理**:
```typescript
// 在浏览器控制台执行或添加到任何页面的useEffect中
localStorage.clear();
indexedDB.deleteDatabase('ConnectLMS-Cache');
```

**验证**: 刷新页面后，所有请求都应走网络，然后被React Query缓存

---

## 📊 阶段三：性能监控和验证 (1小时)

### 步骤 3.1: 添加性能监控

**文件**: `src/hooks/usePerformanceMonitor.ts` (新建)

```typescript
import { useEffect, useRef } from 'react';

export const usePerformanceMonitor = (operationName: string, enabled = true) => {
  const startTimeRef = useRef<number>();

  useEffect(() => {
    if (!enabled) return;
    
    startTimeRef.current = performance.now();
    console.log(`🚀 [性能监控] ${operationName} 开始`);
    
    return () => {
      if (startTimeRef.current) {
        const duration = performance.now() - startTimeRef.current;
        console.log(`✅ [性能监控] ${operationName} 完成，用时: ${duration.toFixed(2)}ms`);
        
        // 记录到性能日志
        if (window.performance && window.performance.mark) {
          window.performance.mark(`${operationName}-end`);
          window.performance.measure(operationName, `${operationName}-start`, `${operationName}-end`);
        }
      }
    };
  }, [operationName, enabled]);

  const markStart = (customName?: string) => {
    const name = customName || operationName;
    startTimeRef.current = performance.now();
    console.log(`🚀 [性能监控] ${name} 开始`);
  };

  const markEnd = (customName?: string) => {
    if (!startTimeRef.current) return;
    
    const name = customName || operationName;
    const duration = performance.now() - startTimeRef.current;
    console.log(`✅ [性能监控] ${name} 完成，用时: ${duration.toFixed(2)}ms`);
    return duration;
  };

  return { markStart, markEnd };
};
```

**文件**: `src/pages/course/hooks/useCourseData.ts`

**添加监控**:
```typescript
import { usePerformanceMonitor } from '@/hooks/usePerformanceMonitor';

export const useCourseData = (courseId: string | undefined) => {
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const { markStart, markEnd } = usePerformanceMonitor('CourseData');
  
  // 在fetchCourseDetails中添加监控
  const fetchCourseDetailsMonitored = async (courseId: string | undefined) => {
    markStart(`课程详情-${courseId}`);
    try {
      const result = await fetchCourseDetails(courseId);
      markEnd(`课程详情-${courseId}`);
      return result;
    } catch (error) {
      markEnd(`课程详情-${courseId}-失败`);
      throw error;
    }
  };

  // 修改useQuery
  const { 
    data: courseData, 
    isLoading: isLoadingCourse,
    refetch: refetchCourseData,
    error: courseError
  } = useQuery({
    queryKey: ['courseDetails', courseId],
    queryFn: () => fetchCourseDetailsMonitored(courseId),
    enabled: !!courseId,
    ...UNIFIED_CACHE_CONFIG.courseDetails
  });
  
  // ... 其他代码保持不变
};
```

### 步骤 3.2: 添加缓存状态监控

**文件**: `src/components/debug/CacheDebugger.tsx` (新建)

```typescript
import React from 'react';
import { useQueryClient } from '@tanstack/react-query';

const CacheDebugger: React.FC = () => {
  const queryClient = useQueryClient();
  
  if (process.env.NODE_ENV !== 'development') {
    return null;
  }
  
  const cache = queryClient.getQueryCache();
  const queries = cache.getAll();
  
  const stats = {
    totalQueries: queries.length,
    activeQueries: queries.filter(q => q.isActive()).length,
    staleQueries: queries.filter(q => q.isStale()).length,
    errorQueries: queries.filter(q => q.state.status === 'error').length,
  };
  
  const courseQueries = queries.filter(q => 
    q.queryKey.some(key => 
      typeof key === 'string' && 
      (key.includes('course') || key.includes('enrollment'))
    )
  );
  
  return (
    <div style={{
      position: 'fixed',
      top: 10,
      right: 10,
      background: 'rgba(0,0,0,0.8)',
      color: 'white',
      padding: '10px',
      borderRadius: '5px',
      fontSize: '12px',
      zIndex: 9999,
      maxWidth: '300px'
    }}>
      <h4>🔍 缓存调试器</h4>
      <div>总查询: {stats.totalQueries}</div>
      <div>活跃: {stats.activeQueries}</div>
      <div>过期: {stats.staleQueries}</div>
      <div>错误: {stats.errorQueries}</div>
      
      <h5>课程相关查询:</h5>
      {courseQueries.slice(0, 5).map((query, index) => (
        <div key={index} style={{ fontSize: '10px', marginBottom: '2px' }}>
          {JSON.stringify(query.queryKey)}: {query.state.status}
        </div>
      ))}
    </div>
  );
};

export default CacheDebugger;
```

**文件**: `src/App.tsx`

**添加调试器**:
```typescript
import CacheDebugger from '@/components/debug/CacheDebugger';

const App = () => {
  return (
    <StrictMode>
      <BrowserRouter>
        <QueryClientProvider client={queryClient}>
          <TooltipProvider>
            <ThemeProvider>
              <AuthProvider>
                <Toaster />
                <Sonner />
                <AppRoutes />
                {/* 开发环境下显示缓存调试器 */}
                <CacheDebugger />
              </AuthProvider>
            </ThemeProvider>
          </TooltipProvider>
        </QueryClientProvider>
      </BrowserRouter>
    </StrictMode>
  );
};
```

---

## 🧪 阶段四：测试和验证 (30分钟)

### 步骤 4.1: 性能基准测试

**在浏览器控制台执行**:
```javascript
// 清除所有缓存
localStorage.clear();
sessionStorage.clear();
indexedDB.deleteDatabase('ConnectLMS-Cache');

// 刷新页面并测试
location.reload();

// 然后测试课程加载时间
console.time('课程页面加载');
// 导航到课程页面
// 在页面加载完成后执行
console.timeEnd('课程页面加载');

// 测试缓存效果 - 第二次访问应该更快
console.time('课程页面缓存加载');
// 再次导航到相同课程页面
console.timeEnd('课程页面缓存加载');
```

### 步骤 4.2: 数据库查询验证

**使用Supabase控制台**:
```sql
-- 检查最近的查询性能
SELECT 
  query,
  mean_exec_time,
  calls,
  total_exec_time
FROM pg_stat_statements 
WHERE query LIKE '%course_enrollments%' 
ORDER BY mean_exec_time DESC 
LIMIT 10;
```

### 步骤 4.3: 网络请求验证

**检查项目**:
1. 打开浏览器开发者工具 → Network
2. 清除网络日志
3. 访问课程页面
4. 确认没有重复的API请求
5. 刷新页面，确认请求被缓存

**成功标志**:
- 相同的API不应在5分钟内重复请求
- 页面刷新后，大部分请求应该被缓存
- 网络面板显示状态为"cached"或"304"

---

## 🔧 阶段五：长期优化 (后续实施)

### 步骤 5.1: 实施渐进式加载

**文件**: `src/services/courseService.ts`

**添加分段加载方法**:
```typescript
// 1. 课程基础信息（最小化加载）
async getCourseEssentials(courseId: string): Promise<CourseEssentials> {
  const { data, error } = await supabase
    .from("courses")
    .select("id, title, description, cover_image, status, author_id")
    .eq("id", courseId)
    .single();

  if (error) throw error;
  return data;
}

// 2. 课程模块概览（按需加载）
async getCourseModulesOverview(courseId: string): Promise<ModuleOverview[]> {
  const { data, error } = await supabase
    .from("course_modules")
    .select("id, title, order_index")
    .eq("course_id", courseId)
    .order("order_index");

  if (error) throw error;
  return data || [];
}

// 3. 模块详细内容（延迟加载）
async getModuleDetails(moduleId: string): Promise<ModuleDetails> {
  const { data, error } = await supabase
    .from("lessons")
    .select("id, title, type, order_index, content")
    .eq("module_id", moduleId)
    .order("order_index");

  if (error) throw error;
  return { lessons: data || [] };
}
```

### 步骤 5.2: 添加预加载策略

**文件**: `src/hooks/usePreloadStrategy.ts` (新建)

```typescript
import { useQueryClient } from '@tanstack/react-query';
import { courseService } from '@/services/courseService';

export const usePreloadStrategy = () => {
  const queryClient = useQueryClient();
  
  const preloadCourseData = async (courseId: string) => {
    // 预加载课程基础信息
    queryClient.prefetchQuery({
      queryKey: ['courseEssentials', courseId],
      queryFn: () => courseService.getCourseEssentials(courseId),
      staleTime: 10 * 60 * 1000,
    });
    
    // 延迟预加载模块概览
    setTimeout(() => {
      queryClient.prefetchQuery({
        queryKey: ['courseModulesOverview', courseId],
        queryFn: () => courseService.getCourseModulesOverview(courseId),
        staleTime: 10 * 60 * 1000,
      });
    }, 1000);
  };
  
  return { preloadCourseData };
};
```

---

## 📈 成功指标和验证清单

### 数据库层面指标
- [ ] 查询平均响应时间 < 200ms  
- [ ] 索引使用率 > 90%
- [ ] 超时错误率 < 1%
- [ ] 504错误基本消失

### 前端缓存指标  
- [ ] 缓存命中率 > 85%
- [ ] 重复请求率 < 5%
- [ ] 页面首次加载时间 < 2s
- [ ] 页面缓存加载时间 < 500ms

### 用户体验指标
- [ ] 课程页面加载稳定
- [ ] 没有明显的加载失败
- [ ] 页面切换流畅
- [ ] 数据一致性良好

---

## 🚨 回滚方案

### 如果数据库优化出现问题：
```sql
-- 删除添加的索引
DROP INDEX IF EXISTS idx_course_enrollments_user_course;
DROP INDEX IF EXISTS idx_courses_status_author;
DROP INDEX IF EXISTS idx_lessons_module_order;
DROP INDEX IF EXISTS idx_course_modules_course_order;
DROP INDEX IF EXISTS idx_lesson_completions_user_course;
```

### 如果前端缓存优化出现问题：
1. 恢复 `src/lib/indexedDBCache.ts` 中的缓存逻辑
2. 恢复 `src/hooks/useCoursesData.ts` 中的localStorage缓存
3. 恢复 `src/App.tsx` 中的原始QueryClient配置

### 紧急恢复命令：
```bash
# 撤销所有本地更改
git checkout -- .

# 或恢复到特定提交
git reset --hard HEAD~1
```

---

## 📋 实施检查清单

**阶段一 - 数据库优化**
- [ ] 执行索引创建SQL
- [ ] 验证索引创建成功  
- [ ] 测试查询性能改善
- [ ] 检查错误日志减少

**阶段二 - 缓存统一**
- [ ] 禁用IndexedDB缓存
- [ ] 禁用localStorage缓存
- [ ] 统一React Query配置
- [ ] 清理现有缓存冲突

**阶段三 - 监控验证**
- [ ] 添加性能监控代码
- [ ] 添加缓存状态调试器
- [ ] 验证监控数据正常

**阶段四 - 测试验证**
- [ ] 执行性能基准测试
- [ ] 验证数据库查询优化
- [ ] 确认网络请求缓存

**阶段五 - 长期优化**
- [ ] 实施渐进式加载
- [ ] 添加预加载策略
- [ ] 持续监控和调优

---

**预计总用时**: 4-6小时  
**建议实施时间**: 用户访问低峰期  
**优先级**: 阶段一和二为高优先级，必须完成

完成后您的LMS系统应该有显著的性能提升！🎉 