# 课程加载问题修复计划书

## 问题分析总结

### 当前错误现象
1. **AbortError**: `AbortError: signal is aborted without reason` 在 src/integrations/supabase/client.ts:25 发生
2. **重复请求**: `course_enrollments` 查询被大量重复执行
3. **Timer 冲突**: 大量 "Timer 'getCourseDetails' already exists" 警告
4. **性能问题**: 页面加载时同一接口被调用多次
5. **🚨 课程数据混乱**: 点击蜜蜂课程却加载狗狗课程的信息（新发现的关键问题）

### 根本原因分析

#### 1. 🔥 错误的课程数据刷新逻辑（新发现 - 最高优先级）
**问题位置**: `src/pages/course/CoursePage.tsx:74-78`
```typescript
useEffect(() => {
  if (lessonId) {
    refreshCourseData(); // ← 错误！lessonId变化不应该刷新课程数据
  }
}, [lessonId, refreshCourseData]);
```

**问题分析**:
- 当用户从一个课程切换到另一个课程时，lessonId的变化触发了refreshCourseData()
- 由于React Query的缓存机制和staleTime设置，可能返回了错误的缓存数据
- 这导致用户点击蜜蜂课程，却看到了狗狗课程的内容

**影响**: 这是导致课程数据混乱的直接原因，严重影响用户体验

#### 2. React Query缓存策略问题（新发现）
**问题位置**: `src/pages/course/hooks/useCourseData.ts:82-89`
```typescript
const CACHE_CONFIG = {
  courseDetails: {
    staleTime: 5 * 60 * 1000,    // 5分钟缓存时间过长
    gcTime: 30 * 60 * 1000,      
    retry: 1,                     
    retryDelay: 1000,            
    refetchOnWindowFocus: false, 
  }
}
```

**问题分析**:
- 5分钟的staleTime导致课程切换时使用旧的缓存数据
- queryKey虽然包含courseId，但缓存失效机制可能有问题
- refreshCourseData的错误调用可能干扰了正常的缓存更新

#### 3. 多组件重复调用 useCourseData
**问题组件**:
- `src/pages/course/CoursePage.tsx:70` - 主要调用：`useCourseData(courseId)`
- `src/pages/course/components/LessonNavigation.tsx:24` - 仅为获取 `refreshCourseData`
- `src/pages/course/components/LessonContent.tsx:70` - 仅为获取 `refreshCourseData`
- 可能还有其他组件

**影响**: 同一页面多个组件同时触发相同的 React Query，导致并发请求冲突

#### 4. Supabase 客户端 AbortController 冲突
**位置**: `src/integrations/supabase/client.ts:25-38`
```typescript
fetch: (url, options) => {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 30000);
  
  return fetch(url, {
    ...options,
    signal: controller.signal // ← 与 React Query 的内置 AbortController 冲突
  }).finally(() => clearTimeout(timeoutId));
}
```

**影响**: 自定义的 AbortController 与 React Query 内置的请求取消机制冲突

#### 5. courseService Timer 冲突
**位置**: `src/services/courseService.ts:186-189, 219-223`
```typescript
console.time('getCourseDetails');  // ← 固定名称
console.time('getCourseBasicInfo'); // ← 固定名称
```

**影响**: 多个并发调用时使用相同的 Timer 名称导致冲突

## 解决方案

### 🚨 阶段 0: 紧急修复课程数据混乱问题（最高优先级）

**目标**: 立即修复点击蜜蜂课程却加载狗狗课程的问题

**修改文件**: `src/pages/course/CoursePage.tsx`

**具体操作**:
1. **移除错误的refreshCourseData调用**
```typescript
// 删除这段错误的代码
useEffect(() => {
  if (lessonId) {
    refreshCourseData(); // ← 删除这行
  }
}, [lessonId, refreshCourseData]);
```

2. **添加courseId变化时的正确处理**
```typescript
// 添加正确的courseId变化处理
useEffect(() => {
  // 只有当courseId变化时才需要刷新课程数据
  if (courseId) {
    // 清除可能的旧缓存，确保获取正确的课程数据
    queryClient.removeQueries({ queryKey: ['courseDetails'] });
    queryClient.removeQueries({ queryKey: ['enrollment'] });
  }
}, [courseId, queryClient]);
```

3. **优化React Query缓存配置**
```typescript
const CACHE_CONFIG = {
  courseDetails: {
    staleTime: 30 * 1000,        // 降低到30秒，确保数据及时更新
    gcTime: 5 * 60 * 1000,       // 降低到5分钟
    retry: 1,
    retryDelay: 1000,
    refetchOnWindowFocus: false,
    refetchOnMount: true,        // 确保挂载时重新获取
  },
  enrollment: {
    staleTime: 30 * 1000,        // 降低到30秒
    gcTime: 2 * 60 * 1000,       // 降低到2分钟
    retry: 1,
    retryDelay: 1000,
    refetchOnWindowFocus: false,
    refetchOnMount: true,        // 确保挂载时重新获取
  }
};
```

### 阶段 1: 修复 Supabase 客户端 AbortController 冲突

**目标**: 移除自定义 fetch 函数中的 AbortController，让 React Query 管理请求取消

**修改文件**: `src/integrations/supabase/client.ts`

**具体操作**:
1. 移除自定义的 fetch 函数中的 AbortController 创建
2. 保留超时机制但使用其他方式实现
3. 让 React Query 的内置 AbortController 机制正常工作

```typescript
// 修改前
fetch: (url, options) => {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 30000);
  
  return fetch(url, {
    ...options,
    signal: controller.signal
  }).finally(() => clearTimeout(timeoutId));
}

// 修改后
fetch: (url, options) => {
  // 如果 React Query 已经提供了 signal，直接使用
  const timeoutId = options?.signal ? null : setTimeout(() => {
    // 只在没有外部 signal 时创建超时
  }, 30000);
  
  return fetch(url, options).finally(() => {
    if (timeoutId) clearTimeout(timeoutId);
  });
}
```

### 阶段 2: 修复 courseService Timer 冲突

**目标**: 解决多个并发请求时的 console.time 冲突

**修改文件**: `src/services/courseService.ts`

**具体操作**:
1. 为每个请求生成唯一的 Timer 名称
2. 使用时间戳或随机数避免冲突

```typescript
// 修改前
console.time('getCourseDetails');

// 修改后
const timerId = `getCourseDetails_${courseId}_${Date.now()}`;
console.time(timerId);
```

### 阶段 3: 创建 CourseDataProvider Context

**目标**: 统一管理课程数据，避免重复调用

**新建文件**: `src/contexts/CourseDataContext.tsx`

**功能设计**:
```typescript
interface CourseDataContextType {
  loading: boolean;
  courseData: (Course & { modules?: CourseModule[] }) | null;
  error: Error | null;
  progress: number;
  enrollmentId: string | null;
  enrollmentStatus: string | undefined;
  findCurrentLesson: (lessonId: string | undefined) => {
    selectedLesson: Lesson | null; 
    selectedUnit: CourseModule | null 
  };
  refreshCourseData: () => Promise<void>;
}
```

**组件包装**:
- 在 `CoursePage` 最顶层使用 `CourseDataProvider`
- 子组件通过 `useCourseDataContext` 获取数据和方法

### 阶段 4: 优化 React Query 缓存配置

**目标**: 减少不必要的网络请求

**修改文件**: `src/pages/course/hooks/useCourseData.ts`

**配置优化**:
```typescript
const CACHE_CONFIG = {
  courseDetails: {
    staleTime: 10 * 60 * 1000,     // 增加到 10 分钟
    gcTime: 60 * 60 * 1000,        // 增加到 1 小时
    retry: 1,
    retryDelay: 1000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,          // 新增：挂载时不重新获取
    refetchOnReconnect: false,      // 新增：重连时不重新获取
  },
  enrollment: {
    staleTime: 5 * 60 * 1000,      // 增加到 5 分钟
    gcTime: 30 * 60 * 1000,        // 增加到 30 分钟
    retry: 1,
    retryDelay: 1000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,          // 新增
    refetchOnReconnect: false,      // 新增
  }
};
```

### 阶段 5: 重构组件调用架构

**目标**: 消除重复的 useCourseData 调用

#### 5.1 修改 CoursePage.tsx
- 保留主要的 `useCourseData` 调用
- 用 `CourseDataProvider` 包装整个页面内容
- 移除不必要的 `refreshCourseData` 调用

#### 5.2 修改 LessonNavigation.tsx
- 移除 `useCourseData` 调用
- 使用 `useCourseDataContext` 获取 `refreshCourseData`

#### 5.3 修改 LessonContent.tsx
- 移除 `useCourseData` 调用
- 使用 `useCourseDataContext` 获取 `refreshCourseData`

#### 5.4 移除不必要的刷新触发
- 移除 CoursePage 中 lessonId 变化时的自动刷新
- 只在真正需要时（如完成课程、提交作业）才调用 refreshCourseData

### 阶段 6: 添加请求去重机制

**目标**: 在 service 层面防止重复请求

**修改文件**: `src/services/courseService.ts`

**实现方案**:
```typescript
// 添加请求去重 Map
const pendingRequests = new Map<string, Promise<any>>();

async getCourseDetails(courseId: string) {
  const requestKey = `courseDetails_${courseId}`;
  
  // 如果已有相同请求在进行中，返回同一个 Promise
  if (pendingRequests.has(requestKey)) {
    return pendingRequests.get(requestKey);
  }
  
  const requestPromise = this._getCourseDetailsImpl(courseId);
  pendingRequests.set(requestKey, requestPromise);
  
  try {
    const result = await requestPromise;
    return result;
  } finally {
    pendingRequests.delete(requestKey);
  }
}
```

## 实施计划

### 第一步: 立即修复 (优先级: 高)
1. **修复 Supabase 客户端 AbortController 冲突**
2. **修复 courseService Timer 冲突**

### 第二步: 架构优化 (优先级: 高)
1. **创建 CourseDataProvider Context**
2. **重构 CoursePage 使用 Provider**

### 第三步: 组件重构 (优先级: 中)
1. **修改 LessonNavigation 组件**
2. **修改 LessonContent 组件**
3. **移除不必要的刷新调用**

### 第四步: 性能优化 (优先级: 中)
1. **优化 React Query 缓存配置**
2. **添加请求去重机制**

### 第五步: 测试验证 (优先级: 高)
1. **验证 AbortError 已解决**
2. **确认没有重复请求**
3. **检查性能改善效果**
4. **测试边界情况和错误处理**

## 预期效果

### 问题解决
- ✅ 消除 AbortError: signal is aborted without reason
- ✅ 消除重复的 course_enrollments 请求
- ✅ 消除 Timer already exists 警告
- ✅ 大幅减少不必要的网络请求

### 性能提升
- 📈 页面加载速度提升 50-70%
- 📈 网络请求数量减少 60-80%
- 📈 内存使用优化
- 📈 用户体验改善

### 代码质量
- 🔧 更清晰的组件架构
- 🔧 更好的数据流管理
- 🔧 更强的错误处理
- 🔧 更易维护的代码结构

## 风险评估

### 低风险
- Supabase 客户端修改（向后兼容）
- Timer 名称修改（不影响功能）

### 中等风险  
- Context 架构重构（需要仔细测试组件间数据传递）
- 缓存配置优化（可能影响数据实时性）

### 缓解措施
- 分阶段实施，每个阶段独立测试
- 保留原有代码的备份
- 充分的单元测试和集成测试
- 在开发环境充分验证后再部署

---

**最后更新时间**: 2024-01-15
**负责人**: AI Assistant
**审核状态**: 待审核
