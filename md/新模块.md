# 模块名称：卡片制作 (Card Creator)

## 1. 模块目标

允许教师在课程中创建一个交互式模块，让学生根据教师设定的要求和模板，输入自己的内容，最终由 AI 动态生成一张包含文本和（可选）生成图像的卡片。

## 2. 核心流程

1.  **教师设置**:
    *   在课程创建/编辑界面，添加"卡片制作"模块。
    *   **输入要求**: 教师明确说明希望学生制作的卡片主题、必须包含的内容点等。
    *   **提供模板 (Template)**: 教师上传一张**图片**或输入一段**文字描述**作为卡片生成的目标样式和布局参考。这不是预设的固定模板，而是针对该任务的即时指导。

2.  **学生操作**:
    *   学生在课程中访问该模块，看到教师的要求和模板预览（如果是图片）。
    *   在指定的输入区域填写自己的文本内容、想法等。

3.  **AI 卡片生成 (核心)**:
    *   学生点击"生成卡片"按钮。
    *   **前端触发**: 将教师的要求、模板（图片或文字描述）以及学生输入的文本发送给 AI 处理逻辑（优先考虑在客户端或 Serverless Function 中使用 TypeScript 实现）。
    *   **LLM 分析与决策 (使用 Claude 3 系列模型)**:
        *   LLM 分析教师的要求和模板（理解图片布局/风格或文字描述）。
        *   LLM 理解学生输入的文本内容。
        *   **智能决策**: LLM 根据模板和要求，判断是否需要生成新的图像来匹配模板中的视觉元素。
        *   **调用图像生成 (如果需要，使用 GPT-4o 或类似 API)**: 如果 LLM 决定需要图像，它会构思合适的图像提示 (prompt)，并调用图像生成 API。
    *   **动态 HTML 生成**: LLM **动态设计** HTML 结构，将学生文本和（如果已生成）AI 生成的图像整合到这个结构中，力求在布局和风格上贴近教师提供的模板。LLM 决定文本和图像的具体位置。
    *   **返回 HTML**: AI 处理逻辑返回生成的 HTML 字符串。

4.  **前端渲染与转换**:
    *   前端接收到 HTML 字符串。
    *   将 HTML 渲染到一个（可能是隐藏的）DOM 元素中。
    *   使用**前端库** (例如 `html2canvas` 或类似技术) 将渲染出的 HTML 内容转换为**图片**格式 (如 PNG 或 JPEG)。

5.  **结果展示与导出**:
    *   向学生展示最终生成的卡片图片。
    *   提供保存或导出该图片的功能。

## 3. 技术选型与实现要点

*   **核心 LLM**: Claude 3 (Opus/Sonnet/Haiku，根据具体需求和成本选择)。
*   **图像生成**: GPT-4o 或其他高质量图像生成 API (如 DALL-E 3)。
*   **主要语言**: TypeScript。
*   **执行环境**: 优先考虑在客户端 (浏览器) 或边缘计算/Serverless Functions (例如 Vercel Functions, Netlify Functions, Supabase Edge Functions) 中执行 AI 调用和逻辑处理，避免或减少传统后端依赖。
*   **HTML 到图片**: 使用前端 JavaScript 库 (如 `html2canvas`)。
*   **模板处理**: 需要能处理教师上传的图片模板（可能需要OCR或图像理解能力来分析布局）或纯文本描述。
*   **状态管理**: 需要有效管理教师设置、学生输入、AI 处理状态以及最终结果。
*   **用户体验**: 异步处理（AI 生成可能耗时），需要提供加载状态和反馈。

##
## 4. 待考虑的细节

*   API 密钥管理和安全性。
*   成本控制（LLM 和图像生成 API 调用）。
*   错误处理（API 调用失败、内容不适宜等）。
*   模板复杂性的处理能力（LLM 能多大程度上还原复杂图片模板的布局？）。
*   生成内容的审核和安全过滤。
*   是否需要保存生成的 HTML 或学生输入的原始数据？（目前设定只保存最终图片）。

## 5. Claude 3 API 调用与图片处理 (通过 OpenRouter)

### 5.1 图片处理流程

1.  **教师上传模板图片**: 教师在设置任务时，上传图片模板。
2.  **上传至 Supabase Storage**: 前端将图片文件上传到 Supabase Storage。
3.  **获取公开 URL**: 从 Supabase 获取该图片的公开访问 URL。
4.  **传递给 LLM**: 将此 URL 作为 Claude 3 API 请求中 `messages` 数组内 `image_url` 对象的值。

### 5.2 API 请求示例 (TypeScript Fetch)

以下是如何使用 `fetch` API 调用 Claude 3.7 Sonnet 模型（通过 OpenRouter），并传递图片 URL 的示例：

```typescript
const openRouterApiKey = process.env.OPENROUTER_API_KEY; // 从环境变量获取
const imageUrlFromSupabase = "SUPABASE_IMAGE_PUBLIC_URL"; // 从 Supabase 获取的图片 URL
const userPrompt = "根据这张图片模板和以下要求，为学生生成卡片HTML..."; // 结合教师要求和学生输入构建的提示

fetch("https://openrouter.ai/api/v1/chat/completions", {
  method: "POST",
  headers: {
    "Authorization": `Bearer ${openRouterApiKey}`,
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    "model": "anthropic/claude-3.7-sonnet", // 注意：截至目前 OpenRouter 可能还没有 3.7，先用 3.5 Sonnet 或 Opus 替代，后续更新
    "messages": [
      {
        "role": "user",
        "content": [
          {
            "type": "text",
            "text": userPrompt
          },
          {
            "type": "image_url",
            "image_url": {
              // 将从 Supabase 获取的 URL 放在这里
              "url": imageUrlFromSupabase
            }
          }
          // 如果还需要传递学生输入的文本，可以再加一个 type: "text" 的对象
          // {
          //   "type": "text",
          //   "text": studentInputText
          // }
        ]
      }
      // 可以根据需要添加更多消息，例如系统提示 (role: "system")
    ],
    // 可以根据需要调整其他参数，如 max_tokens, temperature 等
    // "max_tokens": 1024,
    // "temperature": 0.7
  })
})
.then(response => response.json())
.then(data => {
  console.log("Claude API Response:", data);
  // 在这里处理返回的 HTML 内容 (通常在 data.choices[0].message.content)
})
.catch(error => {
  console.error("Error calling Claude API:", error);
});
```

**注意**:

*   请将 `<OPENROUTER_API_KEY>` 和 `SUPABASE_IMAGE_PUBLIC_URL` 替换为实际值。（移除了 site URL/Name 的占位符）
*   API 密钥应安全存储，不建议直接硬编码在前端代码中。优先使用环境变量，并通过 Serverless Function 或安全的后端代理调用。
*   示例中使用了 `anthropic/claude-3.7-sonnet`，请根据 OpenRouter 提供的最新模型标识符选择合适的 Claude 3 模型。
*   `userPrompt` 需要精心设计，清晰地传达教师的要求、模板的意图以及学生的输入。

## 6. Image Generation API 调用 (TypeScript Example - AI Hub Mix)

以下是一个 TypeScript 函数示例，用于在服务器端环境（如 Node.js 或 Serverless Function）调用 AI Hub Mix 的图像生成 API。它接收一个 prompt（必需）以及可选的 n 和 size 参数。

```typescript
interface GenerateImageParams {
  prompt: string;
  n?: number;
  size?: string;
}

interface ImageGenerationResponse {
  imageUrl?: string;
  error?: string;
  details?: any; // 用于包含 API 的原始错误响应
}

async function generateImageWithAIHubMix(
  params: GenerateImageParams
): Promise<ImageGenerationResponse> {
  const apiKey = process.env.AIHUBMIX_API_KEY || ; // 从环境变量获取或使用默认值 (强烈建议使用环境变量)
  const apiBase = "https://aihubmix.com/v1";
  const imageModel = "gpt-4o-image-vip";
  const imageGenerationUrl = `${apiBase}/images/generations`;

  const { prompt, n = 1, size = "1024x1024" } = params;

  if (!prompt) {
    return { error: "Prompt is required" };
  }

  if (!apiKey) {
      return { error: "AIHUBMIX_API_KEY is not configured." };
  }

  const headers = {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json',
  };

  const payload = {
    model: imageModel,
    prompt: prompt,
    n: n,
    size: size,
    // response_format: "url", // 可以根据需要指定 'url' 或 'b64_json'
  };

  try {
    const response = await fetch(imageGenerationUrl, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(payload),
    });

    const responseData = await response.json();

    if (!response.ok) {
      // API 返回了错误状态码 (4xx, 5xx)
      console.error("AI Hub Mix API Error:", responseData);
      return {
        error: `API Error: ${response.status} ${response.statusText}`,
        details: responseData,
      };
    }

    // 检查返回的数据结构
    if (responseData.data && Array.isArray(responseData.data) && responseData.data.length > 0 && responseData.data[0].url) {
      return { imageUrl: responseData.data[0].url };
    } else {
      console.error("Unexpected response structure:", responseData);
      return {
        error: "Unexpected response structure from AI Hub Mix API",
        details: responseData,
      };
    }

  } catch (error) {
    console.error("Error calling AI Hub Mix API:", error);
    // 处理网络错误或其他 fetch 相关的异常
    if (error instanceof Error) {
        return { error: `Network or fetch error: ${error.message}` };
    }
    return { error: "An unknown error occurred during the API call." };
  }
}

// --- 使用示例 (在 Serverless Function 或 Node.js 环境中) ---
/*
async function handleImageRequest(requestBody: any) {
  if (!requestBody || !requestBody.prompt) {
    return { status: 400, body: { error: "Missing 'prompt' in request body" } };
  }

  const result = await generateImageWithAIHubMix({
    prompt: requestBody.prompt,
    n: requestBody.n, // 可选
    size: requestBody.size, // 可选
  });

  if (result.error) {
    // 根据错误类型返回不同的状态码可能更好，例如 500 或 502
    return { status: 500, body: { error: result.error, details: result.details } };
  }

  return { status: 200, body: { imageUrl: result.imageUrl } };
}

// 假设你有一个接收 POST 请求的入口
// const someRequestBody = { prompt: "A cute cat wearing a hat" };
// handleImageRequest(someRequestBody).then(response => console.log(response));
*/
```

**注意**:

*   此代码设计为在服务器端运行（Node.js, Vercel/Netlify Functions, Supabase Edge Functions 等），因为它包含 API 密钥。
*   **强烈建议**将 `AIHUBMIX_API_KEY` 配置为环境变量，而不是硬编码，以确保安全。
*   错误处理可以根据你的具体需求进一步细化。
*   你需要根据你选择的 Serverless 平台或 Node.js 框架（如 Express）调整入口函数（示例中的 `handleImageRequest`）来处理实际的 HTTP 请求和响应。

## 7. 模块实现方案

### 7.1 组件结构设计

根据之前的需求分析，我们可以将"卡片制作"模块分解为以下主要组件：

```tsx
// 目录结构建议
src/
  components/
    course/
      card-creator/
        CardCreatorTeacher.tsx      // 教师设置界面组件
        CardCreatorStudent.tsx      // 学生使用界面组件
        CardTemplateUploader.tsx    // 模板上传组件
        CardPreview.tsx             // 卡片预览组件
        CardGenerator.tsx           // 卡片生成核心组件
        ImageRenderer.tsx           // HTML到图片渲染组件
  hooks/
    useCardCreator.ts               // 卡片创建相关逻辑的自定义Hook
    useImageGeneration.ts           // 图像生成相关的自定义Hook
  services/
    ai/
      claudeService.ts              // Claude API调用服务
      imageGenerationService.ts     // 图像生成API调用服务
  utils/
    html2image.ts                   // HTML转图片工具函数
```

### 7.2 具体实现示例

#### 7.2.1 教师创建卡片任务组件

```tsx
// CardCreatorTeacher.tsx
import React, { useState } from 'react';
import { Button, Textarea, Input, RadioGroup, Label } from '../ui/components';
import { CardTemplateUploader } from './CardTemplateUploader';
import { supabaseClient } from '../../services/supabase';

interface CardCreatorTeacherProps {
  courseId: string;
  moduleId: string;
  onSave: (data: CardCreatorConfig) => void;
}

interface CardCreatorConfig {
  title: string;
  instructions: string;
  templateType: 'image' | 'text';
  templateImageUrl?: string;
  templateDescription?: string;
}

export function CardCreatorTeacher({ courseId, moduleId, onSave }: CardCreatorTeacherProps) {
  const [config, setConfig] = useState<CardCreatorConfig>({
    title: '',
    instructions: '',
    templateType: 'image',
    templateImageUrl: '',
    templateDescription: '',
  });
  const [isUploading, setIsUploading] = useState(false);

  const handleTextChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setConfig(prev => ({ ...prev, [name]: value }));
  };

  const handleTemplateTypeChange = (value: 'image' | 'text') => {
    setConfig(prev => ({ ...prev, templateType: value }));
  };

  const handleImageUpload = async (file: File) => {
    if (!file) return;
    
    setIsUploading(true);
    try {
      // 生成唯一的文件路径
      const filePath = `courses/${courseId}/modules/${moduleId}/template_${Date.now()}.${file.name.split('.').pop()}`;
      
      // 上传到Supabase Storage
      const { data, error } = await supabaseClient.storage
        .from('course-templates')
        .upload(filePath, file);
      
      if (error) throw error;
      
      // 获取公开URL
      const { data: urlData } = supabaseClient.storage
        .from('course-templates')
        .getPublicUrl(filePath);
      
      setConfig(prev => ({ ...prev, templateImageUrl: urlData.publicUrl }));
    } catch (error) {
      console.error('Error uploading template image:', error);
      alert('模板图片上传失败，请重试');
    } finally {
      setIsUploading(false);
    }
  };

  const handleSubmit = () => {
    // 验证必填字段
    if (!config.title || !config.instructions) {
      alert('请填写标题和说明');
      return;
    }

    // 验证模板
    if (config.templateType === 'image' && !config.templateImageUrl) {
      alert('请上传模板图片');
      return;
    }

    if (config.templateType === 'text' && !config.templateDescription) {
      alert('请填写模板描述');
      return;
    }

    onSave(config);
  };

  return (
    <div className="card-creator-teacher space-y-6">
      <h2 className="text-2xl font-bold">创建卡片制作任务</h2>
      
      <div className="space-y-2">
        <Label htmlFor="title">任务标题</Label>
        <Input 
          id="title"
          name="title"
          value={config.title}
          onChange={handleTextChange}
          placeholder="例：个人职业档案卡制作"
        />
      </div>
      
      <div className="space-y-2">
        <Label htmlFor="instructions">任务说明</Label>
        <Textarea 
          id="instructions"
          name="instructions"
          value={config.instructions}
          onChange={handleTextChange}
          placeholder="请详细描述学生需要在卡片中包含的内容和要求..."
          rows={5}
        />
      </div>
      
      <div className="space-y-4">
        <Label>模板类型</Label>
        <RadioGroup 
          value={config.templateType} 
          onValueChange={handleTemplateTypeChange}
        >
          <div className="flex items-center space-x-2">
            <input type="radio" id="image" value="image" checked={config.templateType === 'image'} />
            <Label htmlFor="image">图片模板</Label>
          </div>
          <div className="flex items-center space-x-2">
            <input type="radio" id="text" value="text" checked={config.templateType === 'text'} />
            <Label htmlFor="text">文字描述</Label>
          </div>
        </RadioGroup>
      </div>
      
      {config.templateType === 'image' ? (
        <div className="space-y-2">
          <Label>上传模板图片</Label>
          <CardTemplateUploader 
            onUpload={handleImageUpload} 
            previewUrl={config.templateImageUrl} 
            isUploading={isUploading}
          />
          <p className="text-sm text-gray-500">
            上传一张图片作为卡片的模板和风格参考。学生将根据此图片的布局和风格创建他们的卡片。
          </p>
        </div>
      ) : (
        <div className="space-y-2">
          <Label htmlFor="templateDescription">模板描述</Label>
          <Textarea 
            id="templateDescription"
            name="templateDescription"
            value={config.templateDescription}
            onChange={handleTextChange}
            placeholder="详细描述卡片的结构、风格、布局等..."
            rows={5}
          />
          <p className="text-sm text-gray-500">
            请详细描述卡片的布局、设计风格、颜色方案等，AI将根据您的描述生成对应风格的卡片。
          </p>
        </div>
      )}
      
      <Button onClick={handleSubmit} disabled={isUploading}>
        保存任务设置
      </Button>
    </div>
  );
}
```

#### 7.2.2 学生使用卡片创建组件

```tsx
// CardCreatorStudent.tsx
import React, { useState } from 'react';
import { Button, Textarea, Spinner } from '../ui/components';
import { CardPreview } from './CardPreview';
import { useCardGenerator } from '../../hooks/useCardGenerator';

interface CardCreatorStudentProps {
  taskData: {
    title: string;
    instructions: string;
    templateType: 'image' | 'text';
    templateImageUrl?: string;
    templateDescription?: string;
  };
}

export function CardCreatorStudent({ taskData }: CardCreatorStudentProps) {
  const [studentInput, setStudentInput] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedCardImageUrl, setGeneratedCardImageUrl] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  const { generateCard } = useCardGenerator();
  
  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setStudentInput(e.target.value);
  };
  
  const handleGenerateCard = async () => {
    if (!studentInput.trim()) {
      setError('请先输入内容');
      return;
    }
    
    setIsGenerating(true);
    setError(null);
    
    try {
      const imageUrl = await generateCard({
        teacherInstructions: taskData.instructions,
        templateType: taskData.templateType,
        templateImageUrl: taskData.templateImageUrl,
        templateDescription: taskData.templateDescription,
        studentInput
      });
      
      setGeneratedCardImageUrl(imageUrl);
    } catch (err) {
      console.error('Error generating card:', err);
      setError('生成卡片时出错，请重试');
    } finally {
      setIsGenerating(false);
    }
  };
  
  const handleDownload = () => {
    if (!generatedCardImageUrl) return;
    
    // 创建一个临时链接并触发下载
    const a = document.createElement('a');
    a.href = generatedCardImageUrl;
    a.download = `card-${Date.now()}.png`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };
  
  return (
    <div className="card-creator-student space-y-6">
      <div className="task-info space-y-4 bg-gray-50 p-4 rounded-md">
        <h3 className="text-xl font-bold">{taskData.title}</h3>
        <p className="text-gray-700">{taskData.instructions}</p>
        
        {taskData.templateType === 'image' && taskData.templateImageUrl && (
          <div className="template-preview">
            <p className="text-sm font-medium mb-2">参考模板：</p>
            <img 
              src={taskData.templateImageUrl} 
              alt="Card Template" 
              className="max-h-60 object-contain rounded-md border border-gray-200"
            />
          </div>
        )}
        
        {taskData.templateType === 'text' && taskData.templateDescription && (
          <div className="template-description">
            <p className="text-sm font-medium mb-2">模板描述：</p>
            <p className="text-gray-600 italic text-sm bg-white p-3 rounded-md border border-gray-200">
              {taskData.templateDescription}
            </p>
          </div>
        )}
      </div>
      
      <div className="student-input space-y-2">
        <label htmlFor="content" className="font-medium block">
          填写你的内容：
        </label>
        <Textarea 
          id="content"
          value={studentInput}
          onChange={handleInputChange}
          placeholder="请根据上述要求输入你的内容..."
          rows={8}
          className="w-full"
        />
      </div>
      
      {error && (
        <div className="error-message text-red-500">
          {error}
        </div>
      )}
      
      <div className="actions">
        <Button 
          onClick={handleGenerateCard} 
          disabled={isGenerating || !studentInput.trim()}
          className="bg-blue-600 hover:bg-blue-700 text-white"
        >
          {isGenerating ? (
            <>
              <Spinner size="sm" />
              <span className="ml-2">生成中...</span>
            </>
          ) : '生成卡片'}
        </Button>
      </div>
      
      {generatedCardImageUrl && (
        <div className="result space-y-4">
          <div className="border-t border-gray-200 pt-4">
            <h3 className="text-lg font-medium mb-3">生成结果：</h3>
            <CardPreview imageUrl={generatedCardImageUrl} />
          </div>
          
          <Button 
            onClick={handleDownload}
            className="bg-green-600 hover:bg-green-700 text-white"
          >
            下载卡片
          </Button>
        </div>
      )}
    </div>
  );
}
```

#### 7.2.3 卡片生成核心逻辑（Hook）

```tsx
// useCardGenerator.ts
import { useState } from 'react';
import { generateHTML } from '../../services/ai/claudeService';
import { generateImageIfNeeded } from '../../services/ai/imageGenerationService';
import { htmlToImage } from '../../utils/html2image';

interface GenerateCardParams {
  teacherInstructions: string;
  templateType: 'image' | 'text';
  templateImageUrl?: string;
  templateDescription?: string;
  studentInput: string;
}

export function useCardGenerator() {
  const [isLoading, setIsLoading] = useState(false);
  
  const generateCard = async (params: GenerateCardParams): Promise<string> => {
    setIsLoading(true);
    
    try {
      // 1. 调用 Claude API 分析需求并生成 HTML
      const { html, imagePrompt } = await generateHTML({
        userPrompt: `
          任务说明: ${params.teacherInstructions}
          
          ${params.templateType === 'text' 
            ? `模板描述: ${params.templateDescription}` 
            : '请分析下面的模板图片，理解其布局和风格。'}
          
          学生输入: ${params.studentInput}
          
          请生成一个HTML卡片，模仿${params.templateType === 'image' ? '图片' : '文字'}模板的风格和布局。
          如果需要生成图片来匹配模板的风格，请提供详细的图片生成提示。
          输出格式：JSON，包含两个字段 {html: "完整的HTML代码", imagePrompt: "如需生成图片的提示，否则为null"}
        `,
        imageUrl: params.templateType === 'image' ? params.templateImageUrl : undefined
      });
      
      // 2. 如果 Claude 决定需要生成图片，调用图像生成 API
      let imageUrl: string | null = null;
      
      if (imagePrompt) {
        imageUrl = await generateImageIfNeeded(imagePrompt);
      }
      
      // 3. 如果生成了图片，将图片 URL 插入到 HTML 中
      let finalHtml = html;
      if (imageUrl) {
        // 简单替换占位符，实际情况可能需要更复杂的替换逻辑
        finalHtml = html.replace('__IMAGE_PLACEHOLDER__', imageUrl);
      }
      
      // 4. 将 HTML 渲染为图片
      const cardImageUrl = await htmlToImage(finalHtml);
      
      return cardImageUrl;
    } catch (error) {
      console.error('Error in card generation process:', error);
      throw new Error('卡片生成失败');
    } finally {
      setIsLoading(false);
    }
  };
  
  return {
    generateCard,
    isLoading
  };
}
```

#### 7.2.4 Claude API 服务

```tsx
// claudeService.ts
interface GenerateHTMLParams {
  userPrompt: string;
  imageUrl?: string;
}

interface ClaudeResponse {
  html: string;
  imagePrompt: string | null;
}

export async function generateHTML({ userPrompt, imageUrl }: GenerateHTMLParams): Promise<ClaudeResponse> {
  const openRouterApiKey = process.env.OPENROUTER_API_KEY;
  
  if (!openRouterApiKey) {
    throw new Error('OpenRouter API key is not configured');
  }
  
  // 准备消息内容
  const messages = [
    {
      role: "user",
      content: [
        {
          type: "text",
          text: userPrompt
        }
      ]
    }
  ];
  
  // 如果提供了图片URL，添加到消息中
  if (imageUrl) {
    messages[0].content.push({
      type: "image_url",
      image_url: {
        url: imageUrl
      }
    });
  }
  
  try {
    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${openRouterApiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "anthropic/claude-3.7-sonnet",
        messages: messages,
        response_format: { type: "json_object" }
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Claude API error: ${JSON.stringify(errorData)}`);
    }
    
    const data = await response.json();
    const contentString = data.choices[0].message.content;
    
    // 解析JSON响应
    try {
      const contentObj = JSON.parse(contentString);
      return {
        html: contentObj.html,
        imagePrompt: contentObj.imagePrompt
      };
    } catch (e) {
      console.error('Failed to parse Claude response as JSON:', e);
      // 如果解析失败，尝试直接使用返回的内容作为HTML
      return {
        html: contentString,
        imagePrompt: null
      };
    }
  } catch (error) {
    console.error('Error calling Claude API:', error);
    throw new Error('文本分析失败，请重试');
  }
}
```

#### 7.2.5 图像生成服务

```tsx
// imageGenerationService.ts
export async function generateImageIfNeeded(prompt: string | null): Promise<string | null> {
  if (!prompt) return null;
  
  const apiKey = process.env.AIHUBMIX_API_KEY;
  
  if (!apiKey) {
    console.error('AIHUBMIX_API_KEY is not configured');
    return null;
  }
  
  const apiBase = "https://aihubmix.com/v1";
  const imageGenerationUrl = `${apiBase}/images/generations`;
  
  try {
    const response = await fetch(imageGenerationUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: "gpt-4o-image-vip",
        prompt: prompt,
        n: 1,
        size: "1024x1024",
      })
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }
    
    const responseData = await response.json();
    
    if (responseData.data && Array.isArray(responseData.data) && responseData.data.length > 0) {
      return responseData.data[0].url;
    }
    
    return null;
  } catch (error) {
    console.error('Error generating image:', error);
    return null;
  }
}
```

#### 7.2.6 HTML转图片工具

```tsx
// html2image.ts
export async function htmlToImage(html: string): Promise<string> {
  // 创建一个隐藏的容器来渲染HTML
  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.left = '-9999px';
  container.style.top = '-9999px';
  container.style.width = '1024px'; // 固定宽度以确保一致的渲染
  container.innerHTML = html;
  
  // 必须将容器添加到DOM才能渲染
  document.body.appendChild(container);
  
  try {
    // 动态导入html2canvas
    const html2canvas = (await import('html2canvas')).default;
    
    // 等待字体和图像加载完成
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // 将HTML转换为canvas
    const canvas = await html2canvas(container, {
      allowTaint: true,  // 允许渲染跨域图像
      useCORS: true,     // 尝试使用CORS加载跨域图像
      scale: 2,          // 2x 缩放以获得更高的质量
      backgroundColor: null  // 透明背景
    });
    
    // 将canvas转换为数据URL
    const dataUrl = canvas.toDataURL('image/png');
    return dataUrl;
  } finally {
    // 清理：从DOM中移除容器
    if (container.parentNode) {
      container.parentNode.removeChild(container);
    }
  }
}
```

### 7.3 数据模型

为了存储卡片任务和学生提交的信息，我们可以在Supabase中创建以下表结构：

```sql
-- 卡片创建任务表
CREATE TABLE card_creator_tasks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  course_id UUID NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  instructions TEXT NOT NULL,
  template_type TEXT NOT NULL CHECK (template_type IN ('image', 'text')),
  template_image_url TEXT,
  template_description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id)
);

-- 学生卡片提交表
CREATE TABLE card_creator_submissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  task_id UUID NOT NULL REFERENCES card_creator_tasks(id) ON DELETE CASCADE,
  student_id UUID NOT NULL REFERENCES auth.users(id),
  content TEXT NOT NULL,
  card_image_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建索引
CREATE INDEX card_creator_tasks_course_id_idx ON card_creator_tasks(course_id);
CREATE INDEX card_creator_submissions_task_id_idx ON card_creator_submissions(task_id);
CREATE INDEX card_creator_submissions_student_id_idx ON card_creator_submissions(student_id);
```

### 7.4 安全与性能考虑

1. **API 密钥安全性**：
   - 通过环境变量管理所有API密钥
   - 使用Serverless Functions隐藏API调用细节，避免将密钥暴露给前端
   - 设置适当的CORS策略和请求速率限制

2. **图像存储**：
   - 使用Supabase Storage存储教师上传的模板图片和生成的卡片图片
   - 设置适当的访问控制策略

3. **成本控制**：
   - 对AI调用设置配额和限制
   - 考虑缓存常见模板的处理结果
   - 压缩生成的图片以减少存储空间

4. **错误处理与重试机制**：
   - 为AI调用实现优雅的错误处理
   - 在服务不可用时提供友好的用户反馈
   - 对关键API调用实现重试逻辑

5. **可访问性**：
   - 确保生成的卡片有适当的alt文本
   - 提供卡片内容的文本版本供屏幕阅读器使用

### 7.5 测试策略

1. **单元测试**：测试各个组件和工具函数的功能

2. **集成测试**：测试AI服务调用和图像生成流程

3. **用户测试**：
   - 测试不同类型模板的效果
   - 测试各种输入内容场景
   - 测试边缘情况（很长的输入文本、特殊字符等）

4. **性能测试**：测量卡片生成的响应时间和资源消耗
