# 增量保存功能实现方案

## 问题分析

当前的保存机制存在以下问题：
1. **全量保存**：每次点击保存都会保存整个课程的所有数据（课程信息 + 所有模块 + 所有课时）
2. **效率低下**：即使只修改了一个课时，也要重新保存所有数据
3. **用户体验差**：保存时间长，用户等待时间久

## 解决方案

实现增量保存，在课时编辑器中点击保存时只保存当前编辑的课时，而不是保存整个课程。

## 实现步骤

### 步骤1：创建增量保存钩子 `useIncrementalSave` ✅ 已完成

增量保存钩子已经创建在 `src/hooks/useIncrementalSave.ts`，提供了 `saveLesson` 方法来保存单个课时。

### 步骤2：修改课时编辑器的保存逻辑 ✅ 已完成

在 `CourseTabContent.tsx` 中，已经集成了增量保存功能：

```typescript
const { saveLesson } = useIncrementalSave({ courseId: course.id });
const updateLesson = async (moduleId: string, lessonId: string, updatedLesson: Lesson | null) => {
  if (!updatedLesson) {
    setCurrentLesson(null);
    return;
  }
  
  // 更新本地状态
  const updatedModules = modules.map(module => {
    if (module.id === moduleId) {
      const updatedLessons = module.lessons.map(lesson => 
        lesson.id === lessonId ? { ...updatedLesson } : lesson
      );
      return { ...module, lessons: updatedLessons };
    }
    return module;
  });
  
  setModules(updatedModules);
  
  // 使用增量保存，只保存这个课时
  await saveLesson(updatedLesson);
  
  setCurrentLesson(null);
};
```

### 步骤3：修改 `LessonEditor` 组件，只使用增量保存

需要修改 `src/components/course/LessonEditor.tsx` 中的 `handleSubmit` 函数，移除全量保存逻辑：

**当前的问题：**
```typescript
const handleSubmit = async (data) => {
  // ... 处理课时数据 ...
  
  // 首先调用增量保存
  onSave(updatedLesson);
  
  // 然后又调用全量保存（这是问题所在）
  if (onCourseDataSaved) {
    await onCourseDataSaved(updatedLesson); // 这会保存整个课程
  }
};
```

**需要修改为：**
```typescript
const handleSubmit = async (data) => {
  // ... 处理课时数据 ...
  
  // 只调用增量保存
  onSave(updatedLesson);
  
  // 移除全量保存逻辑，直接显示成功消息并返回
  toast.success('课时已保存');
  form.reset(data);
  onSave(null); // 返回到课程结构页面
};
```

**具体修改：**

找到 `handleSubmit` 函数中的这部分代码：
```typescript
// 首先更新课程内容的状态
onSave(updatedLesson);

// 然后如果提供了数据库保存回调，则调用它保存到数据库
if (onCourseDataSaved) {
  try {
    const toastId = toast.loading('正在保存课程到数据库...');
    console.log('即将保存到数据库的课时数据:', JSON.stringify(updatedLesson));
    await onCourseDataSaved(updatedLesson);
    toast.success('保存成功', { id: toastId });
    form.reset(data);
    onSave(null);
  } catch (error) {
    console.error('保存失败:', error);
    toast.error(`保存失败: ${error instanceof Error ? error.message : '未知错误'}`);
  }
}
```

修改为：
```typescript
// 只使用增量保存
onSave(updatedLesson);

// 显示保存成功消息并返回
toast.success('课时已保存');
form.reset(data);
onSave(null); // 返回到课程结构页面
```

## 用户体验改进

### 1. 明确的保存提示
- 保存课时时显示"课时已保存"
- 保存速度快，用户体验好

### 2. 保存状态指示
- 保存按钮文本从"保存课程"改为"保存课时"
- 让用户明确知道保存的是什么内容

### 3. 保持现有功能
- 全量保存功能仍然保留，用于课程头部的"保存课程"按钮
- 发布课程时的最终保存仍使用全量保存

## 技术优势

1. **性能提升**：只保存当前课时，减少网络传输和数据库写入
2. **用户体验**：保存速度快，反馈及时
3. **简单明确**：用户明确知道只保存了当前课时
4. **向后兼容**：不影响现有的全量保存功能

## 注意事项

1. **数据一致性**：确保增量保存不会导致数据不一致
2. **错误处理**：增量保存失败时给出明确的错误提示
3. **兼容性**：保持与现有全量保存功能的兼容

这个简化方案直接解决用户的核心需求：在课时编辑器中点击保存时只保存当前课时，不进行复杂的全量保存操作。

## 补充问题：框架类型课时中的子课时保存

### 问题分析

在实现了基本的增量保存后，发现了一个新问题：在课程框架(frame)类型的课时中，编辑子课时时点击保存，还是会触发全量保存而不是增量保存。

**问题根因：**
1. FrameLessonEditor 组件有自己的子课时编辑逻辑
2. 当编辑子课时时，会调用 LessonEditor 组件
3. 在调用时传递了 `onCourseDataSaved` 参数，导致子课时保存时还是使用全量保存
4. 这与主要的增量保存策略不一致

**具体代码位置：**
在 `FrameLessonEditor.tsx` 中：
```typescript
// 当前的问题代码
<LessonEditor 
  lesson={currentEditingLesson}
  onSave={handleSaveSubLessonAndExit}
  onContentChange={(newSubLessonC) => {
    handleSubLessonContentChange(currentEditingLesson.id, newSubLessonC);
  }}
  onCourseDataSaved={handleSubLessonEditorDirectSave}  // 这里导致全量保存
/>
```

### 解决方案：统一子课时的增量保存

**步骤4：修改 FrameLessonEditor 组件**

需要修改 `src/components/course/FrameLessonEditor.tsx` 中的子课时编辑逻辑：

**当前的问题：**
```typescript
<LessonEditor 
  lesson={currentEditingLesson}
  onSave={handleSaveSubLessonAndExit}
  onContentChange={(newSubLessonC) => {
    handleSubLessonContentChange(currentEditingLesson.id, newSubLessonC);
  }}
  onCourseDataSaved={handleSubLessonEditorDirectSave}  // 这会触发全量保存
/>
```

**需要修改为：**
```typescript
<LessonEditor 
  lesson={currentEditingLesson}
  onSave={handleSaveSubLessonAndExit}
  onContentChange={(newSubLessonC) => {
    handleSubLessonContentChange(currentEditingLesson.id, newSubLessonC);
  }}
  // 移除 onCourseDataSaved 参数，让子课时使用增量保存
/>
```

**修改说明：**
1. **移除全量保存回调**：不传递 `onCourseDataSaved` 参数
2. **使用增量保存**：子课时编辑将自动使用我们在步骤3中实现的增量保存逻辑
3. **保持数据同步**：确保 `handleSaveSubLessonAndExit` 函数正确更新框架的本地状态
4. **保留框架保存**：框架本身的"保存到数据库"按钮保持不变，用于保存整个框架结构

**预期效果：**
- 在框架中编辑子课时时，点击"保存课时"只保存当前子课时
- 子课时保存后会更新到框架的本地状态
- 框架整体的保存功能不受影响
- 所有课时编辑行为保持一致

### 其他需要检查的地方

**类似问题排查：**
需要检查其他可能存在相同问题的地方：

1. **ResourceLessonEditor**: 检查是否也有类似的全量保存调用
2. **HotspotEditor**: 检查热点编辑器的保存逻辑
3. **CardCreatorLessonEditor**: 检查卡片创建器的保存逻辑
4. **DragSortEditor**: 检查拖拽排序编辑器的保存逻辑

**统一保存策略：**
确保所有特殊类型的课时编辑器都遵循同一原则：
- 课时内容的修改使用增量保存
- 只有在明确需要保存整个课程时才使用全量保存
- 保存按钮的文本要明确表示保存的范围（"保存课时" vs "保存课程"）

这样就能实现完全一致的增量保存体验，无论是在哪种类型的课时编辑器中。
